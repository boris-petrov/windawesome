
Windawesome

Windawesome (pronounced - contrary to what you would expect from the way it is written - Windows-om, not Wind-awesome) is a highly customizable dynamic window manager for Windows, which works on top of explorer.exe and NOT as a shell replacement. It is heavily inspired by Bug.n, but it goes much furthur. Windawesome is (mostly) written in C# and is scriptable and pluggable in IronRuby, IronPython and any .NET language that compiles down to an assembly. Requires .NET Framework 4 Client Profile, Visual C++ 2010 Redistributable and IronRuby/IronPython DLLs. The main bundle comes with 3 configuration files (2 in Python, 1 in Ruby), 3 layouts (2 built-in and one as a C# DLL), a couple of Plugins and some Widgets, one of which is written in Ruby. Works with 32- and 64-bit versions of Windows XP, Vista and 7. Goes under the GNU General Public License version 2.

Installation:
You can build from sources, which would require at least Visual Studio 2010 and the IronPython/IronRuby DLLs (see below). If you don't want, you could just use the binaries I have built, but you still need .NET 4, VC++ 2010 redist and the IronPython/IronRuby DLLs (IronPython.dll, IronPython.Modules.dll, IronRuby.dll, IronRuby.Libraries.dll, Microsoft.Dynamic.dll, Microsoft.Scripting.dll). All the configuration that comes with Windawesome is the one that I use on my machine - you probably won't like it so make sure to go through all config files and customize as you like.

Usage:
If you've run Windawesome, you'll probably notice that you don't know how to exit. You can do that by pressing ALT+SHIFT+Q - at least that's the default hotkey if you haven't changed it. For all others, take a look at the config files and modify them as per your taste.

Terminology:
Window - a window
IBar - a vertical bar that is docked at the top or the bottom of the screen
Bar - an implementation of IBar using Windows Forms
Workspace - what you see at any point is exactly one workspace. Every workspace can have zero or more windows, and every window can be on zero or more workspaces. Every workspace can have zero or more IBars and every IBar can be on zero or more workspaces (but exactly once on each)
IWidget - something that is shown in a Bar. Every IWidget instance should be on at most one Bar and every Bar can have zero or more widgets
Plugin - just something that is loaded in the beginning and can do various things

Configuration:
Configuration files are read in order so if you use something in one file from another, make sure the other one is read first. There are 4 directories which are read in the following order: Layouts, Widgets, Plugins, Config

Config:
This is the global configuration unit of Windawesome. These instance variables are set in the configuration files and should ALL be given values.
plugins - an array of IPlugin objects
bars - an array of IBar objects
layouts - an array of ILayout objects
workspaces - an array of Workspace objects
workspacesCount - the number of elements in the "workspaces" array
startingWorkspace - the ID of the workspace to be shown when the application is run (1-based)
programRules - an array of ProgramRule objects
borderWidth - the thickness of the sizing border, in pixels. The default is 1 pixel
paddedBorderWidth - the thickness of the padded border, in pixels. The default value is 4 pixels. Only in Vista or later
uniqueHotkey - Windawesome uses this hotkey so it can switch to applications when you change workspaces (only if another method fails). Make sure you use a unique hotkey that is not in use by any other application. Windawesome will output a warning in a warnings.txt file if there is a problem registering this hotkey. The default one probably is fine (it is ALT+0)

ProgramRule:
A program rule tells Windawesome how to treat any newly created window - this can be customized in a variety of ways:

className - the window class name, a regular expression
displayName - the window display name, a regular expression
processName - the name of the process (which is the name of the executable without the extension), a regular expression
styleContains - the window styles that must be present in the window's style
styleNotContains - the window styles that must NOT be present in the window's style
exStyleContains - the extended window styles that must be present in the window's extended style
exStyleNotContains - the extended window styles that must NOT be present in the window's extended style
customMatchingFunction - a delegate of type "bool CustomMatchingFunction(IntPtr hWnd)" which is called after each rule that matches all of the above variables. It should return true if the rule is to be matched and false otherwise. The default one returns true if the window has no owner

isManaged - whether Windawesome should care about that window
tryAgainAfter - the time, in milliseconds, to wait before trying to match the rules again (if >= 0)
windowCreatedDelay - the time, in milliseconds, to wait before taking any action after the window has been created (if > 0). Windawesome will match te rules and then sleep. If Windawesome has problems with newly created windows, try setting this to a higher value
handleOwnedWindows - if true, Windawesome will handle a window that is owned by this one. Useful for applications using the VCL framework as they use a window which owns the "real" window
hideOwnedPopups - if true, Windawesome will hide all popups that are owned of the window being hidden
redrawDesktopOnWindowCreated - if true, Windawesome will redraw the Desktop when this window is created. Useful if you have problems with that. I've seen it with mintty (the cygwin terminal emulator)
onWindowCreatedAction - specifies what to do when a window is created. Can be one of the enum values:
	SwitchToWindowsWorkspace - switches to that window's workspace. The default value
	MoveWindowToCurrentWorkspace - moves the window to the current workspace
	TemporarilyShowWindowOnCurrentWorkspace - shows the window but doesn't move it to the current workspace. Can be dismissed by calling DismissTemporarilyShownWindow
	HideWindow - hides the window (this option doesn't always work - try putting a bigger number for windowCreatedDelay)
onHiddenWindowShownAction - specifies what to do when a hidden window suddenly shows itself. Can be one of the enum values:
	SwitchToWindowsWorkspace - switches to that window's workspace. The default value
	MoveWindowToCurrentWorkspace - moves the window to the current workspace
	TemporarilyShowWindowOnCurrentWorkspace - shows the window but doesn't move it to the current workspace. Can be dismissed by calling DismissTemporarilyShownWindow
	HideWindow - hides the window
showOnWorkspacesCount - if > 0, the window is going to be shown on that number workspaces, starting from the first one. So if showOnWorkspacesCount == number of workspaces, then the window is shown on all workspace. Note this is different than not managing the window
rules - a list of Rule objects

Whenever a new window is created, Windawesome tries to match it with any program rule in config.programRules. "className" through "customMatchingFunction", including, must all match. The FIRST matching rule is used, that is why an "all-catch" rule should be at the end. After that, if a window is not managed, Windawesome does nothing more - which means you will see the window on every workspace and as a normal, floating window.

Rule:
Each rule governs the specific settings for a window on a particular workspace

workspace - the workspace ID to put the window on
isFloating - whether the window is floating, i.e. the layout shouldn't manage it
showInTabs - whether the window will show in Windawesome's Application Tabs Widget
titlebar - whether the window's titlebar is SHOWN, HIDDEN or AS_IS (the last one means that Windawesome will not do anything to the titlebar - do NOT use that if the window is shared, i.e. visible on two or more workspaces, if on any of the others it is not AS_IS)
inTaskbar - whether the window is SHOWN, HIDDEN or AS_IS in Window's taskbar
windowBorders - whether the window's border is SHOWN, HIDDEN or AS_IS (the last one means that Windawesome will not do anything to the border - do NOT use that if the window is shared, i.e. visible on two or more workspaces, if on any of the others it is not AS_IS)
redrawOnShow - whether the window should be redrawed when shown. Some windows (e.g. Excel) have a problem when hidden and then shown again
activateLastActivePopup - whether Windawesome should activate the last active popup of the window, instead of the window itself. This is normally what you want as most windows that a top-level window creates are popups and they should be above the main window

Bar:
An IBar is a horizontal... well, bar, that is docked to the top or the bottom of the screen. The Bar implementation contains IWidgets which can be left, right or middle aligned. The following customizations can be done:

leftAlignedWidgets - a list of IFixedWidthWidget objects which are going to be left-aligned on the bar. They will show from left to right, i.e. the leftmost edge of the first object in the list is going to be at the leftmost position on the screen
rightAlignedWidgets - a list of IFixedWidthWidget objects which are going to be right-aligned on the bar. They will show from left to right, i.e. the rightmost edge of the last object in the list is going to be at the rightmost position on the screen
middleAlignedWidgets - a list of IFSpanWidget objects which are going to span all the available space in the middle of the bar
barHeight - the height of the bar, in pixels
font - the default font to be used for any Widget, if it does not specify anything else
backgroundColor - the default background color of the Bar

Left and right aligned widgets SHOULD be of type IFixedWidthWidget (which means they are not spanning all the available space, not that they cannot change their width), while middle aligned widgets SHOULD be of type ISpanWidget.

Workspace:
A workspace contains windows and bars and is displaying the windows in a particular layout.

layout - the layout to be used to position windows
barsAtTop - a list of IBar objects to be visible at the top of this workspace
barsAtBottom - a list of IBar objects to be visible at the bottom of this workspace
name - a short, descriptive name that is going to be shown next to the workspace ID in the Workspaces Widget
showWindowsTaskbar - a boolean to indicate whether to show the Windows taskbar initially on this workspace
repositionOnSwitchedTo - a boolean indicating whether to reposition all windows when this workspace has been switched to


Layouts:
Full screen - nothing to be customized there
Floating - nothing to be customized there
Tile:
Contains a master area and a stack area.

layoutAxis - the way to position the master and stack area in respect to each other - LeftToRight means master on the left, stack on the right and so on. Monocle is full screen, i.e. the master and stack area overlap each other
masterAreaAxis - the way to position the windows in the master area in respect to each other
stackAreaAxis - the way to position the windows in the stack area in respect to each other
masterAreaFactor - a number between 0 and 1 indicating the percentage of the working area for the master area
masterAreaWindowsCount - an initial count for the number of windows in the master area
API:
AddToMasterAreaWindowsCount - adds a number to the masterAreaWindowsCount. Can be negative
ToggleLayoutAxis - toggles the next layout in the layout axis
ToggleMasterAreaAxis - toggles the next layout in the master area axis
ToggleStackAreaAxis - toggles the next layout in the stack area axis
SetLayoutAxis - accepts a LayoutAxis and sets the layout axis to that value
SetMasterAreaAxis - accepts a LayoutAxis and sets the master area axis to that value
SetStackAreaAxis - accepts a LayoutAxis and sets the stack area axis to that value
ShiftWindowToNextPosition - accepts a Window and shifts it to the next position
ShiftWindowToPreviousPosition - accepts a Window and shifts it to the previous position
ShiftWindowToMainPosition - accepts a Window and shifts it to the main position (top of master area)
AddToMasterAreaFactor - a double to add to the master area factor. Can be negative


IWidgets:
Things you put on a Bar to display various info.
Workspaces Widget:
normalForegroundColor - an array of ten Colors. Whenever the workspace is not selected and it contains N windows, normalForegroundColor[N] is going to be used as a foreground color
normalBackgroundColor - an array of ten Colors. Whenever the workspace is not selected and it contains N windows, normalBackgroundColor[N] is going to be used as a background color
highlightedForegroundColor - the Color to be used when the workspace is the current one
highlightedBackgroundColor - the Color to be used when the workspace is the current one
flashingForegroundColor - the Color to be used when the workspace is flashing
flashingBackgroundColor - the Color to be used when the workspace is flashing
flashWorkspaces - boolean indicating whether to flash the workspace or not when some window in it is flashing

Layout Widget - accepts a background and a foreground color as arguments

System Tray Widget - accepts a boolean indicating whether to show the hidden tray icons too (Windows 7 only)

DateTime Widget - accepts a string to format the DateTime object, as well as back- and fore-colors, update time (in milliseconds, specifying how often to update the value) and a handler for a click

Application Tabs Widget - accepts a boolean indicating whether to show a single tab for the foreground application only, or to show all windows. 4 arguments for colors too

CpuMonitorWidget - accepts the time in milliseconds to wait before updating the value (should be at least 500) and a prefix and a suffix to display


Plugins:
WindowSubclassing - I tried to make a plugin which would subclass all windows and then catch movement, maximization, restoration and stuff like that on workspaces that shouldn't allow actions like that (e.g. full-screen). It works but Windows seems to have problems with that kind of things, so I would suggest you don't use it. You can try, however.

LoggerPlugin - a plugin which logs in a file what windows are created/destroyed/minimized/activated/restored and what workspaces are activated. Useful if you have problems with some programs to see what window classes are created so you can ignore them in your config files.

ShortcutsManager - allows you to use keyboard shortcuts. If you use only non-left or right modifier keys (Control, Alt, etc), it uses RegisterHotKey function which will fail if there is already a global shortcut with this key and these modifiers. If, however, you have one or more shortcuts that have a left or right-only modifier (LControl, RAlt, etc), then it registers a low-level keyboard hook which will work fine with colliding mappings if you return false from your handler. I do suggest, however, that you use only non-left/right shortcuts (Control, Shift, etc) and use non-colliding mappings.



Usage tips:
- Windawesome will change the so called "working area" of Windows to take the maximum available space - this means, for example, that if the Windows Taskbar is not shown when you maximize a window, it will take the area of the Taskbar too. Whenever changing between workspaces, Windawesome will set the new workspace's working area according to its settings (how many bars are shown, where they are located, whether the Taskbar is shown). This is very useful, however changing the working area in Windows takes, for some reason, a *very* long time - like a second - which is *very* annoying. This means that having two or more workspaces with different settings for bar heights and Taskbar visibility will lead to constant changing of the working area when you switch between them. I would suggest that you have some bars (not necessarily the same) for each workspace, but with the same height, and hiding or showing the Windows Taskbar on all of them. This will make switching between workspaces instantaneous. Take a look at my configuration to see what I mean.
- I highly suggest you run Windawesome elevated (in Vista and above) as otherwise it's not going to be able to manage elevated windows, due to the UIPI changes since Vista. Which is very irritating, trust me. One more thing is that Windawesome (if not running elevated) will not be able to switch to the topmost window when changing workspaces if on the previous the active program was an elevated one. If you would like to run Windawesome, or any program, elevated without the UIC prompt, you can read how to do that here:
http://maximumpcguides.com/windows-vista/run-a-program-with-administrative-privileges-without-uac-prompts/
- If you are using Alt + number to switch between workspaces, I HIGHLY recommend using these two lines in an AutoHotkey script:
~LAlt Up::return
~RAlt Up::return
This will remove the Windows standard behaviour of the Alt key which focuses keyboard input on the menu of the current application. This is VERY useful because sometimes when switching workspaces the focus is on the menu of the newly shown application and not on the app itself.

Known bugs/limitations:
- Whenever a label's text is longer than the width, ellipsis show. However, then the text alignment changes to Top or something. This is a bug in the .NET Framework since version 2.0 and hasn't been fixed even in 4.0. Should be relatively easy to fix that by drawing one's own text, but I won't bother.
- There is a minor chance that the System Tray Widget is not going to work properly in some case. Let me know if that happens with the exact scenario.
- Currently only one monitor is supported. Unfortunatelly I have only one and I cannot test it even if I wrote something for multimonitor support. Feel free to let me know if you know exactly how it should be done or if you want to do it. :)
- Do not change the resolution of the monitor when Windawesome is running if you have other programs that dock to the end of the screen other than the Windows taskbar. It will not work right. First quit either Windawesome or the programs and then change the resolution.

For any suggestions, complaints or the likes, feel free to write to boris underscore petrov at live dot com.
